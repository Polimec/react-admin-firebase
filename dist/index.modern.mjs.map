{"version":3,"file":"index.modern.mjs","sources":["../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/logger/logger-base.ts","../src/misc/logger/firestore-logger.ts","../src/misc/logger/logger.ts","../src/misc/dispatcher.ts","../src/misc/internal.models.ts","../src/misc/translate-from-firestore.ts","../src/misc/document-parser.ts","../src/misc/pathHelper.ts","../src/misc/translate-to-firestore.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/AuthProvider.ts","../src/misc/status-code-translator.ts","../src/providers/database/ResourceManager.ts","../src/providers/database/FireClient.ts","../src/misc/storage-parser.ts","../src/misc/metadata-parser.ts","../src/misc/firebase-models.ts","../src/providers/lazy-loading/queryCursors.ts","../src/providers/lazy-loading/paramsToQuery.ts","../src/providers/lazy-loading/FirebaseLazyLoadingClient.ts","../src/providers/DataProvider.ts","../src/providers/queries/GetList.ts","../src/providers/queries/GetOne.ts","../src/providers/queries/GetMany.ts","../src/providers/queries/GetManyReference.ts","../src/providers/commands/Update.ts","../src/providers/commands/UpdateMany.ts","../src/providers/commands/Create.ts","../src/providers/commands/Delete.ts","../src/providers/commands/Delete.Soft.ts","../src/providers/commands/DeleteMany.ts","../src/providers/commands/DeleteMany.Soft.ts"],"sourcesContent":["import { get, isEmpty } from 'lodash';\nimport { getFieldReferences, SearchObj } from './objectFlatten';\n\nexport function sortArray(\n  data: Array<{}>,\n  field: string,\n  dir: 'asc' | 'desc'\n): void {\n  data.sort((a: {}, b: {}) => {\n    const rawA = get(a, field);\n    const rawB = get(b, field);\n    const isAsc = dir === 'asc';\n\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\n    if (isNumberField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    const isStringField = typeof rawA === 'string' && typeof rawB === 'string';\n    if (isStringField) {\n      const aParsed = rawA.toLowerCase();\n      const bParsed = rawB.toLowerCase();\n      return basicSort(aParsed, bParsed, isAsc);\n    }\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\n    if (isDateField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    return basicSort(!!rawA, !!rawB, isAsc);\n  });\n}\n\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\n  if (aValue > bValue) {\n    return isAsc ? 1 : -1;\n  }\n  if (aValue < bValue) {\n    return isAsc ? -1 : 1;\n  }\n  return 0;\n}\n\nexport function filterArray(\n  data: Array<{}>,\n  searchFields?: { [field: string]: string | number | boolean | null }\n): Array<{}> {\n  if (!searchFields || isEmpty(searchFields)) {\n    return data;\n  }\n  const searchObjs: SearchObj[] = [];\n  Object.keys(searchFields).map((fieldName) => {\n    const fieldValue = searchFields[fieldName];\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\n    searchObjs.push(...getSubObjects);\n  });\n  const filtered = data.filter((row) =>\n    searchObjs.reduce((acc, cur) => {\n      const res = doesRowMatch(row, cur.searchField, cur.searchValue);\n      return res && acc;\n    }, true as boolean)\n  );\n  return filtered;\n}\n\nexport function doesRowMatch(\n  row: {},\n  searchField: string,\n  searchValue: any\n): boolean {\n  const searchThis = get(row, searchField);\n  const bothAreFalsey = !searchThis && !searchValue;\n  if (bothAreFalsey) {\n    return true;\n  }\n  const nothingToSearch = !searchThis;\n  if (nothingToSearch) {\n    return false;\n  }\n  const isStringSearch = typeof searchValue === 'string';\n  if (isStringSearch) {\n    return searchThis\n      .toString()\n      .toLowerCase()\n      .includes(searchValue.toLowerCase());\n  }\n  const isBooleanOrNumber =\n    typeof searchValue === 'boolean' || typeof searchValue === 'number';\n  if (isBooleanOrNumber) {\n    return searchThis === searchValue;\n  }\n  const isArraySearch = Array.isArray(searchValue);\n  if (isArraySearch) {\n    return searchValue.includes(searchThis);\n  }\n  return false;\n}\n","type SearchValues = {} | number | string | boolean | null;\ntype SearchValue = SearchValues | SearchValue[];\n\nexport interface SearchObj {\n  searchField: string;\n  searchValue: SearchValue;\n}\nexport function getFieldReferences(\n  fieldName: string,\n  value: {} | SearchValue\n): SearchObj[] {\n  const isFalsy = !value;\n  const isSimple =\n    isFalsy ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean';\n\n  if (isSimple) {\n    return [\n      {\n        searchField: fieldName,\n        searchValue: value as SearchValue,\n      },\n    ];\n  }\n  const tree = {} as Record<string, SearchValue>;\n  tree[fieldName] = value;\n  return objectFlatten(tree);\n}\n\nexport function objectFlatten(tree: {}): SearchObj[] {\n  var leaves: SearchObj[] = [];\n  var recursivelyWalk = (obj: any, path: string | null) => {\n    path = path || '';\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const objVal = obj && obj[key];\n        const currentPath = !!path ? path + '.' + key : key;\n        const isWalkable =\n          typeof objVal === 'object' || objVal instanceof Array;\n        if (isWalkable) {\n          recursivelyWalk(objVal, currentPath);\n        } else {\n          leaves.push({ searchField: currentPath, searchValue: objVal });\n        }\n      }\n    }\n  };\n  recursivelyWalk(tree, null);\n  return leaves;\n}\n","type LogFn = (...args: any) => void;\n\nexport const LogNoOp: LogFn = (...args: any) => null;\n\nexport class LoggerBase {\n  constructor(private title: string, private cacheEnabledKey: string) {}\n\n  private isEnabled() {\n    return !!localStorage.getItem(this.cacheEnabledKey);\n  }\n\n  SetEnabled(isEnabled: boolean) {\n    if (isEnabled) {\n      localStorage.setItem(this.cacheEnabledKey, 'true');\n    } else {\n      localStorage.removeItem(this.cacheEnabledKey);\n    }\n  }\n\n  public get log() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.log.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get warn() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.warn.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get error() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.error.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n}\n","import { RAFirebaseOptions } from 'providers/options';\nimport { LoggerBase, LogNoOp } from './logger-base';\n\nconst LOGGER_ENABLEDKEY = 'LOGGING_FIRESTORE_COSTS_ENABLED';\nconst logger = new LoggerBase('ðŸ’¸firestore-costs:', LOGGER_ENABLEDKEY);\n\nconst KEY_SINGLE = 'firecosts-single-reads';\n\nexport interface IFirestoreLogger {\n  logDocument: (count: number) => Function;\n  SetEnabled: (isEnabled: boolean) => void;\n  ResetCount: (shouldReset: boolean) => void;\n}\n\nexport function MakeFirestoreLogger(\n  options: RAFirebaseOptions\n): IFirestoreLogger {\n  function notEnabled() {\n    return !options?.lazyLoading?.enabled;\n  }\n\n  function incrementRead(incrementBy = 1) {\n    const currentCountRaw = localStorage.getItem(KEY_SINGLE) || '';\n    const currentCount = parseInt(currentCountRaw) || 0;\n    const incremented = currentCount + incrementBy;\n    localStorage.setItem(KEY_SINGLE, incremented + '');\n    return incremented;\n  }\n  function clearCache() {\n    localStorage.removeItem(KEY_SINGLE);\n  }\n  return {\n    SetEnabled(isEnabled: boolean) {\n      logger.SetEnabled(isEnabled);\n    },\n    ResetCount(shouldReset: boolean) {\n      shouldReset && clearCache();\n    },\n    logDocument(docCount: number) {\n      if (notEnabled()) {\n        return LogNoOp;\n      }\n      const count = incrementRead(docCount);\n      const suffix = `+${docCount} (session total=${count} documents read)`;\n      const boundLogFn: (...args: any) => void = logger.log.bind(\n        console,\n        suffix\n      );\n      return boundLogFn;\n    },\n  };\n}\n","import { LoggerBase } from './logger-base';\n\nconst LOGGER_ENABLEDKEY = 'LOGGING_ENABLED';\nexport const logger = new LoggerBase('ðŸ”¥raf:', LOGGER_ENABLEDKEY);\n\nexport const log = logger.log;\nexport const logError = logger.error;\nexport const logWarn = logger.warn;\n","import { log } from './logger';\n\nexport type DispatchEvent =\n  | 'FILE_UPLOAD_WILL_START'\n  | 'FILE_UPLOAD_PROGRESS'\n  | 'FILE_UPLOAD_PAUSED'\n  | 'FILE_UPLOAD_RUNNING'\n  | 'FILE_UPLOAD_CANCELED'\n  | 'FILE_UPLOAD_COMPLETE'\n  | 'FILE_SAVED';\n\nexport function dispatch(\n  eventName: DispatchEvent,\n  fileName: string,\n  data?: any\n): void {\n  const eventMonitor = document.getElementById('eventMonitor');\n  if (!eventMonitor) {\n    log(\n      `eventMonitor not found to dispatch event ${eventName} for ${fileName}`\n    );\n    return;\n  }\n  const eventData = { fileName, data };\n  let event = new CustomEvent(eventName, { detail: eventData });\n  eventMonitor.dispatchEvent(event);\n}\n","export const REF_INDENTIFIER = '___REF_FULLPATH_';\n\nexport interface ParsedRefDoc {\n  ___refpath: string;\n  ___refid: string;\n}\n","import { getDownloadURL, ref } from 'firebase/storage';\nimport { has, set } from 'lodash';\nimport { IFirebaseWrapper } from 'providers/database';\nimport { FireStoreDocumentRef } from './firebase-models';\nimport { REF_INDENTIFIER } from './internal.models';\nimport { logError } from './logger';\n\nexport interface RefDocFound {\n  fieldPath: string;\n  refDocPath: string;\n}\n\nexport interface FromFirestoreResult {\n  parsedDoc: any;\n  refdocs: RefDocFound[];\n}\n\nexport function translateDocFromFirestore(obj: any) {\n  const isObject = !!obj && typeof obj === 'object';\n  const result: FromFirestoreResult = {\n    parsedDoc: {},\n    refdocs: [],\n  };\n  if (!isObject) {\n    return result;\n  }\n  Object.keys(obj).map((key) => {\n    const value = obj[key];\n    obj[key] = recusivelyCheckObjectValue(value, key, result);\n  });\n  result.parsedDoc = obj;\n  return result;\n}\n\nexport function recusivelyCheckObjectValue(\n  input: any,\n  fieldPath: string,\n  result: FromFirestoreResult\n): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isPrimitive = typeof input !== 'object';\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as any[]).map((value, index) =>\n      recusivelyCheckObjectValue(value, `${fieldPath}.${index}`, result)\n    );\n  }\n  const isDocumentReference = isInputADocReference(input);\n  if (isDocumentReference) {\n    const documentReference = input as FireStoreDocumentRef;\n    result.refdocs.push({\n      fieldPath: fieldPath,\n      refDocPath: documentReference.path,\n    });\n    return documentReference.id;\n  }\n  const isObject = typeof input === 'object';\n  if (isObject) {\n    Object.keys(input).map((key) => {\n      const value = input[key];\n      input[key] = recusivelyCheckObjectValue(value, key, result);\n    });\n    return input;\n  }\n  return input;\n}\n\nfunction isInputADocReference(input: any): boolean {\n  const isDocumentReference =\n    typeof input.id === 'string' &&\n    typeof input.firestore === 'object' &&\n    typeof input.parent === 'object' &&\n    typeof input.path === 'string';\n  return isDocumentReference;\n}\n\nexport function applyRefDocs(doc: any, refDocs: RefDocFound[]) {\n  refDocs.map((d) => {\n    set(doc, REF_INDENTIFIER + d.fieldPath, d.refDocPath);\n  });\n  return doc;\n}\n\nexport const recursivelyMapStorageUrls = async (\n  fireWrapper: IFirebaseWrapper,\n  fieldValue: any\n): Promise<any> => {\n  const isPrimitive = !fieldValue || typeof fieldValue !== 'object';\n  if (isPrimitive) {\n    return fieldValue;\n  }\n  const isFileField = has(fieldValue, 'src');\n  if (isFileField) {\n    try {\n      const src = await getDownloadURL(\n        ref(fireWrapper.storage(), fieldValue.src)\n      );\n      return {\n        ...fieldValue,\n        src,\n      };\n    } catch (error) {\n      logError(`Error when getting download URL`, {\n        error,\n      });\n      return fieldValue;\n    }\n  }\n  const isArray = Array.isArray(fieldValue);\n  if (isArray) {\n    return Promise.all(\n      (fieldValue as any[]).map(async (value, index) => {\n        fieldValue[index] = await recursivelyMapStorageUrls(fireWrapper, value);\n      })\n    );\n  }\n  const isDocumentReference = isInputADocReference(fieldValue);\n  if (isDocumentReference) {\n    return fieldValue;\n  }\n  const isObject = !isArray && typeof fieldValue === 'object';\n  if (isObject) {\n    return Promise.all(\n      Object.keys(fieldValue).map(async (key) => {\n        const value = fieldValue[key];\n        fieldValue[key] = await recursivelyMapStorageUrls(fireWrapper, value);\n      })\n    );\n  }\n};\n","import {\n  FireStoreDocumentSnapshot,\n  FireStoreQueryDocumentSnapshot,\n} from './firebase-models';\nimport { logWarn } from './logger';\nimport * as ra from './react-admin-models';\nimport {\n  applyRefDocs,\n  translateDocFromFirestore,\n} from './translate-from-firestore';\n\nexport function parseFireStoreDocument<T extends ra.Record>(\n  doc: FireStoreQueryDocumentSnapshot | FireStoreDocumentSnapshot | undefined\n): T {\n  if (!doc) {\n    logWarn('parseFireStoreDocument: no doc', { doc });\n    return {} as T;\n  }\n  const data = doc.data();\n  const result = translateDocFromFirestore(data);\n  const dataWithRefs = applyRefDocs(result.parsedDoc, result.refdocs);\n  // React Admin requires an id field on every document,\n  // So we can just use the firestore document id\n  return { id: doc.id, ...dataWithRefs } as T;\n}\n","import path from 'path-browserify';\n\nexport function getAbsolutePath(\n  rootRef: undefined | string | (() => string),\n  relativePath: string | null\n): string {\n  if (!rootRef) {\n    return relativePath + '';\n  }\n  if (!relativePath) {\n    throw new Error(\n      'Resource name must be a string of length greater than 0 characters'\n    );\n  }\n  const rootRefValue = typeof rootRef === 'string' ? rootRef : rootRef();\n  const withSlashes = path.join('/', rootRefValue, '/', relativePath, '/');\n  const slashCount = withSlashes.split('/').length - 1;\n  if (slashCount % 2) {\n    throw new Error(`The rootRef path must point to a \"document\"\n    not a \"collection\"e.g. /collection/document/ or\n    /collection/document/collection/document/`);\n  }\n  return withSlashes.slice(1, -1);\n}\n\nexport function joinPaths(...args: string[]) {\n  return path.join(...args);\n}\n","import { REF_INDENTIFIER } from './internal.models';\n\ninterface ParsedUpload {\n  fieldDotsPath: string;\n  fieldSlashesPath: string;\n  rawFile: File | any;\n}\n\ninterface ParsedDocRef {\n  fieldDotsPath: string;\n  refPath: string;\n}\n\ninterface ParseResult {\n  parsedDoc: any;\n  uploads: ParsedUpload[];\n  refdocs: ParsedDocRef[];\n}\n\nexport function translateDocToFirestore(obj: any): ParseResult {\n  const isObject = !!obj && typeof obj === 'object';\n  const result: ParseResult = {\n    uploads: [],\n    refdocs: [],\n    parsedDoc: {},\n  };\n  if (!isObject) {\n    return result;\n  }\n  Object.keys(obj).map((key) => {\n    const value = obj[key];\n    recusivelyParseObjectValue(value, key, result);\n  });\n  result.parsedDoc = obj;\n  return result;\n}\n\nexport function recusivelyParseObjectValue(\n  input: any,\n  fieldPath: string,\n  result: ParseResult\n): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isRefField =\n    typeof fieldPath === 'string' && fieldPath.includes(REF_INDENTIFIER);\n  if (isRefField) {\n    const refDocFullPath = input as string;\n    result.refdocs.push({\n      fieldDotsPath: fieldPath,\n      refPath: refDocFullPath,\n    });\n    return;\n  }\n  const isPrimitive = typeof input !== 'object';\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as []).map((value, index) =>\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, result)\n    );\n  }\n  const isFileField = !!input && input.hasOwnProperty('rawFile');\n  if (isFileField) {\n    result.uploads.push({\n      fieldDotsPath: fieldPath,\n      fieldSlashesPath: fieldPath.split('.').join('/'),\n      rawFile: input.rawFile,\n    });\n    delete input.rawFile;\n    return;\n  }\n  Object.keys(input).map((key) => {\n    const value = input[key];\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, result);\n  });\n  return input;\n}\n","import { FirebaseApp, getApp, getApps, initializeApp } from 'firebase/app';\nimport {\n  browserLocalPersistence,\n  browserSessionPersistence,\n  getAuth,\n  inMemoryPersistence,\n  onAuthStateChanged,\n  Persistence,\n  signInWithEmailAndPassword,\n  signOut,\n} from 'firebase/auth';\nimport {\n  collection,\n  doc,\n  getFirestore,\n  serverTimestamp as firestoreServerTimestamp,\n  writeBatch,\n} from 'firebase/firestore';\nimport {\n  getDownloadURL,\n  getStorage,\n  ref,\n  uploadBytesResumable,\n} from 'firebase/storage';\nimport {\n  FireApp,\n  FireAuth,\n  FireAuthUserCredentials,\n  FireStorage,\n  FireStoragePutFileResult,\n  FireStore,\n  FireStoreBatch,\n  FireStoreCollectionRef,\n  FireUploadTaskSnapshot,\n  FireUser,\n} from 'misc/firebase-models';\nimport { log } from '../../../misc';\nimport { RAFirebaseOptions } from '../../options';\nimport { IFirebaseWrapper } from './IFirebaseWrapper';\n\nconsole.log('WTF?!');\nexport class FirebaseWrapper implements IFirebaseWrapper {\n  private readonly _app: FireApp;\n  private readonly _firestore: FireStore;\n  private readonly _storage: FireStorage;\n  private readonly _auth: FireAuth;\n  public options: RAFirebaseOptions;\n\n  constructor(inputOptions: RAFirebaseOptions | undefined, firebaseConfig: {}) {\n    const optionsSafe = inputOptions || {};\n    this.options = optionsSafe;\n    this._app = (window as any)['_app'] = ObtainFirebaseApp(\n      firebaseConfig,\n      optionsSafe\n    );\n\n    console.log('firebaseConfig', firebaseConfig);\n    console.log('getFirestore', getFirestore);\n    this._firestore = (getFirestore as any)(\n      this._app,\n      (firebaseConfig as any).database || ''\n    );\n    this._storage = getStorage(this._app);\n    this._auth = getAuth(this._app);\n  }\n  dbGetCollection(absolutePath: string): FireStoreCollectionRef {\n    return collection(this._firestore, absolutePath);\n  }\n  dbCreateBatch(): FireStoreBatch {\n    return writeBatch(this._firestore);\n  }\n  dbMakeNewId(): string {\n    return doc(collection(this._firestore, 'collections')).id;\n  }\n\n  public OnUserLogout(callBack: (u: FireUser | null) => any) {\n    this._auth.onAuthStateChanged((user) => {\n      const isLoggedOut = !user;\n      log('FirebaseWrapper.OnUserLogout', { user, isLoggedOut });\n      if (isLoggedOut) {\n        callBack(user);\n      }\n    });\n  }\n  putFile(storagePath: string, rawFile: any): FireStoragePutFileResult {\n    const task = uploadBytesResumable(ref(this._storage, storagePath), rawFile);\n    const taskResult = new Promise<FireUploadTaskSnapshot>((res, rej) =>\n      task.then(res).catch(rej)\n    );\n\n    const downloadUrl = taskResult\n      .then((t) => getDownloadURL(t.ref))\n      .then((url) => url as string);\n\n    return {\n      task,\n      taskResult,\n      downloadUrl,\n    };\n  }\n  async getStorageDownloadUrl(fieldSrc: string): Promise<string> {\n    return getDownloadURL(ref(this._storage, fieldSrc));\n  }\n  public serverTimestamp() {\n    // This line doesn't work for some reason, might be firebase sdk.\n    return firestoreServerTimestamp();\n  }\n\n  async authSetPersistence(persistenceInput: 'session' | 'local' | 'none') {\n    let persistenceResolved: Persistence;\n    switch (persistenceInput) {\n      case 'local':\n        persistenceResolved = browserLocalPersistence;\n        break;\n      case 'none':\n        persistenceResolved = inMemoryPersistence;\n        break;\n      case 'session':\n      default:\n        persistenceResolved = browserSessionPersistence;\n        break;\n    }\n\n    log('setPersistence', { persistenceInput, persistenceResolved });\n\n    return this._auth\n      .setPersistence(persistenceResolved)\n      .catch((error) => console.error(error));\n  }\n  async authSigninEmailPassword(\n    email: string,\n    password: string\n  ): Promise<FireAuthUserCredentials> {\n    const user = await signInWithEmailAndPassword(this._auth, email, password);\n    return user;\n  }\n  async authSignOut(): Promise<void> {\n    return signOut(this._auth);\n  }\n  async authGetUserLoggedIn(): Promise<FireUser> {\n    return new Promise((resolve, reject) => {\n      const auth = this._auth;\n      if (auth.currentUser) return resolve(auth.currentUser);\n      const unsubscribe = onAuthStateChanged(this._auth, (user) => {\n        unsubscribe();\n        if (user) {\n          resolve(user);\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n  public async GetUserLogin(): Promise<FireUser> {\n    return this.authGetUserLoggedIn();\n  }\n\n  /** @deprecated */\n  public auth(): FireAuth {\n    return this._auth;\n  }\n  /** @deprecated */\n  public storage(): FireStorage {\n    return this._storage;\n  }\n  /** @deprecated */\n  public GetApp(): FireApp {\n    return this._app;\n  }\n  /** @deprecated */\n  public db(): FireStore {\n    return this._firestore;\n  }\n}\n\nfunction ObtainFirebaseApp(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n): FirebaseApp {\n  if (options.app) {\n    return options.app;\n  }\n  const apps = getApps();\n\n  const isInitialized = !!apps?.length;\n\n  if (isInitialized) {\n    return getApp();\n  } else {\n    return initializeApp(firebaseConfig);\n  }\n}\n","import { log, logger, logWarn, retrieveStatusTxt } from '../misc';\nimport { FireUser } from '../misc/firebase-models';\nimport {\n  AuthProvider as RaAuthProvider,\n  UserIdentity,\n} from '../misc/react-admin-models';\nimport { messageTypes } from './../misc/messageTypes';\nimport { IFirebaseWrapper } from './database';\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\nimport { RAFirebaseOptions } from './options';\n\nclass AuthClient {\n  private fireWrapper: IFirebaseWrapper;\n\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\n    const options = optionsInput || {};\n    log('Auth Client: initializing...', { firebaseConfig, options });\n    this.fireWrapper = new FirebaseWrapper(options, firebaseConfig);\n    options.persistence && this.setPersistence(options.persistence);\n  }\n\n  setPersistence(persistenceInput: 'session' | 'local' | 'none') {\n    return this.fireWrapper.authSetPersistence(persistenceInput);\n  }\n\n  public async HandleAuthLogin(params: { username: string; password: string }) {\n    const { username, password } = params;\n\n    if (username && password) {\n      try {\n        const user = await this.fireWrapper.authSigninEmailPassword(\n          username,\n          password\n        );\n        log('HandleAuthLogin: user sucessfully logged in', { user });\n        return user;\n      } catch (e) {\n        log('HandleAuthLogin: invalid credentials', { params });\n        throw new Error('Login error: invalid credentials');\n      }\n    } else {\n      return this.getUserLogin();\n    }\n  }\n\n  public HandleAuthLogout() {\n    return this.fireWrapper.authSignOut();\n  }\n\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\n    log('HandleAuthLogin: invalid credentials', { errorHttp });\n    const status = !!errorHttp && errorHttp.status;\n    const statusTxt = retrieveStatusTxt(status);\n    if (statusTxt === 'ok') {\n      log('API is actually authenticated');\n      return Promise.resolve();\n    }\n    logWarn('Received authentication error from API');\n    return Promise.reject();\n  }\n\n  public async HandleAuthCheck(): Promise<any> {\n    return this.getUserLogin();\n  }\n\n  public getUserLogin(): Promise<FireUser> {\n    return this.fireWrapper.authGetUserLoggedIn();\n  }\n\n  public async HandleGetPermissions() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.claims;\n    } catch (e) {\n      log('HandleGetPermission: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetIdentity(): Promise<UserIdentity> {\n    try {\n      const { uid, displayName, photoURL } = await this.getUserLogin();\n      const identity: UserIdentity = {\n        id: uid,\n        fullName: `${displayName ?? ''}`,\n        avatar: `${photoURL ?? ''}`,\n      };\n      return identity;\n    } catch (e) {\n      log('HandleGetIdentity: no user is logged in', {\n        e,\n      });\n      return null as any;\n    }\n  }\n\n  public async HandleGetJWTAuthTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.authTime;\n    } catch (e) {\n      log('HandleGetJWTAuthTime: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetJWTExpirationTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.expirationTime;\n    } catch (e) {\n      log(\n        'HandleGetJWTExpirationTime: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTSignInProvider() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.signInProvider;\n    } catch (e) {\n      log(\n        'HandleGetJWTSignInProvider: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTIssuedAtTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.issuedAtTime;\n    } catch (e) {\n      log(\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTToken() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.token;\n    } catch (e) {\n      log('HandleGetJWTToken: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n}\n\nexport function AuthProvider(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n): ReactAdminFirebaseAuthProvider {\n  VerifyAuthProviderArgs(firebaseConfig, options);\n  logger.SetEnabled(!!options?.logging);\n  const auth = new AuthClient(firebaseConfig, options);\n\n  const provider: ReactAdminFirebaseAuthProvider = {\n    // React Admin Interface\n    login: (params) => auth.HandleAuthLogin(params),\n    logout: () => auth.HandleAuthLogout(),\n    checkAuth: () => auth.HandleAuthCheck(),\n    checkError: (error) => auth.HandleAuthError(error),\n    getPermissions: () => auth.HandleGetPermissions(),\n    getIdentity: () => auth.HandleGetIdentity(),\n    // Custom Functions\n    getAuthUser: () => auth.getUserLogin(),\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\n    getJWTClaims: () => auth.HandleGetPermissions(),\n    getJWTToken: () => auth.HandleGetJWTToken(),\n  };\n  return provider;\n}\n\nexport type ReactAdminFirebaseAuthProvider = RaAuthProvider & {\n  // Custom Functions\n  getAuthUser: () => Promise<FireUser>;\n  getJWTAuthTime: () => Promise<string | null>;\n  getJWTExpirationTime: () => Promise<string | null>;\n  getJWTSignInProvider: () => Promise<string | null>;\n  getJWTClaims: () => Promise<{ [key: string]: any } | null>;\n  getJWTToken: () => Promise<string | null>;\n};\n\nfunction VerifyAuthProviderArgs(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\n    );\n  }\n}\n","// From firebase SDK\n\nimport { logError } from './logger';\n\n// tslint:disable-next-line:max-line-length\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusTxt(status: number): 'ok' | 'unauthenticated' {\n  // Make sure any successful status is OK.\n  if (status >= 200 && status < 300) {\n    return 'ok';\n  }\n  switch (status) {\n    case 401: // 'unauthenticated'\n    case 403: // 'permission-denied'\n      return 'unauthenticated';\n\n    case 0: // 'internal'\n    case 400: // 'invalid-argument'\n    case 404: // 'not-found'\n    case 409: // 'aborted'\n    case 429: // 'resource-exhausted'\n    case 499: // 'cancelled'\n    case 500: // 'internal'\n    case 501: // 'unimplemented'\n    case 503: // 'unavailable'\n    case 504: // 'deadline-exceeded'\n    default:\n      // ignore\n      return 'ok';\n  }\n}\n\n// From firebase SDK\n// tslint:disable-next-line:max-line-length\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusCode(statusTxt: string): number {\n  // Make sure any successful status is OK.\n  const regexResult = /\\[code\\=([\\w-]*)/g.exec(statusTxt);\n  const status = Array.isArray(regexResult) && regexResult[1];\n  if (!status) {\n    logError('unknown StatusCode ', { statusTxt });\n  }\n  switch (status) {\n    case 'unauthenticated':\n      return 401;\n    case 'permission-denied':\n      return 403;\n    case 'internal':\n      return 0;\n    case 'invalid-argument':\n      return 400;\n    case 'not-found':\n      return 404;\n    case 'aborted':\n      return 409;\n    case 'resource-exhausted':\n      return 429;\n    case 'cancelled':\n      return 499;\n    case 'internal':\n      return 500;\n    case 'unimplemented':\n      return 501;\n    case 'unavailable':\n      return 503;\n    case 'deadline-exceeded':\n      return 504;\n    default:\n      return 200;\n  }\n}\n","import { doc, getDoc, getDocs } from 'firebase/firestore';\nimport { FireStoreCollectionRef, FireStoreQuery } from 'misc/firebase-models';\nimport {\n  getAbsolutePath,\n  IFirestoreLogger,\n  log,\n  logWarn,\n  messageTypes,\n  parseFireStoreDocument,\n} from '../../misc';\nimport { RAFirebaseOptions } from '../options';\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\n\ntype IResourceItem = {} & { id: string; deleted?: boolean };\nexport interface IResource {\n  path: string;\n  pathAbsolute: string;\n  collection: FireStoreCollectionRef;\n  list: Array<IResourceItem>;\n}\n\nexport class ResourceManager {\n  private resources: Record<string, IResource> = {};\n\n  constructor(\n    private fireWrapper: IFirebaseWrapper,\n    private options: RAFirebaseOptions,\n    private flogger: IFirestoreLogger\n  ) {\n    this.fireWrapper.OnUserLogout(() => {\n      this.resources = {};\n    });\n  }\n\n  public async TryGetResource(\n    resourceName: string,\n    refresh?: 'REFRESH',\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    if (refresh) {\n      await this.RefreshResource(resourceName, collectionQuery);\n    }\n    return this.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n\n  public GetResource(relativePath: string): IResource {\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Can't find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async TryGetResourcePromise(\n    relativePath: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    log('resourceManager.TryGetResourcePromise', {\n      relativePath,\n      collectionQuery,\n    });\n    await this.initPath(relativePath);\n\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async RefreshResource(\n    relativePath: string,\n    collectionQuery: messageTypes.CollectionQueryType | undefined\n  ) {\n    if (this.options?.lazyLoading?.enabled) {\n      logWarn('resourceManager.RefreshResource', {\n        warn: 'RefreshResource is not available in lazy loading mode',\n      });\n      throw new Error(\n        'react-admin-firebase: RefreshResource is not available in lazy loading mode'\n      );\n    }\n\n    log('resourceManager.RefreshResource', { relativePath, collectionQuery });\n    await this.initPath(relativePath);\n    const resource = this.resources[relativePath];\n\n    const collectionRef = resource.collection;\n    const collectionOrQuery = this.applyQuery(collectionRef, collectionQuery);\n    const newDocs = await getDocs(collectionOrQuery);\n\n    resource.list = [];\n    newDocs.forEach((d) =>\n      resource.list.push(parseFireStoreDocument<IResourceItem>(d))\n    );\n\n    const count = newDocs.docs.length;\n    this.flogger.logDocument(count)();\n    log('resourceManager.RefreshResource', {\n      newDocs,\n      resource,\n      collectionPath: collectionRef.path,\n    });\n  }\n\n  public async GetSingleDoc(relativePath: string, docId: string) {\n    await this.initPath(relativePath);\n    const resource = this.GetResource(relativePath);\n    this.flogger.logDocument(1)();\n    const docSnap = await getDoc(doc(resource.collection, docId));\n    if (!docSnap.exists) {\n      throw new Error('react-admin-firebase: No id found matching: ' + docId);\n    }\n    const result = parseFireStoreDocument(docSnap);\n    log('resourceManager.GetSingleDoc', {\n      relativePath,\n      resource,\n      docId,\n      docSnap,\n      result,\n    });\n    return result;\n  }\n\n  private async initPath(relativePath: string): Promise<void> {\n    const rootRef = this.options && this.options.rootRef;\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\n    const hasBeenInited = !!this.resources[relativePath];\n    log('resourceManager.initPath()', {\n      absolutePath,\n      hasBeenInited,\n    });\n    if (hasBeenInited) {\n      log('resourceManager.initPath() has been initialized already...');\n      return;\n    }\n    const collection = this.fireWrapper.dbGetCollection(absolutePath);\n    const list: Array<IResourceItem> = [];\n    const resource: IResource = {\n      collection,\n      list,\n      path: relativePath,\n      pathAbsolute: absolutePath,\n    };\n    this.resources[relativePath] = resource;\n    log('resourceManager.initPath() setting resource...', {\n      resource,\n      allResources: this.resources,\n      collection: collection,\n      collectionPath: collection.path,\n    });\n  }\n\n  public async getUserIdentifier(): Promise<string> {\n    const identifier = this.options.associateUsersById\n      ? await this.getCurrentUserId()\n      : await this.getCurrentUserEmail();\n    return identifier;\n  }\n\n  private async getCurrentUserEmail() {\n    const user = await this.fireWrapper.authGetUserLoggedIn();\n    if (user) {\n      return user.email as string;\n    } else {\n      return 'annonymous user';\n    }\n  }\n  private async getCurrentUserId() {\n    const user = await this.fireWrapper.authGetUserLoggedIn();\n    if (user) {\n      return user.uid;\n    } else {\n      return 'annonymous user';\n    }\n  }\n\n  private applyQuery(\n    collection: FireStoreCollectionRef,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): FireStoreCollectionRef | FireStoreQuery {\n    const collRef = collectionQuery ? collectionQuery(collection) : collection;\n\n    log('resourceManager.applyQuery() ...', {\n      collection,\n      collectionQuery: (collectionQuery || '-').toString(),\n      collRef,\n    });\n    return collRef;\n  }\n}\n","import { doc } from 'firebase/firestore';\nimport { get, set } from 'lodash';\nimport {\n  AddCreatedByFields,\n  AddUpdatedByFields,\n  dispatch,\n  IFirestoreLogger,\n  log,\n  logError,\n  parseStoragePath,\n  translateDocToFirestore,\n} from '../../misc';\nimport {\n  TASK_CANCELED,\n  TASK_PAUSED,\n  TASK_RUNNING,\n} from '../../misc/firebase-models';\nimport { RAFirebaseOptions } from '../options';\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\nimport { IResource, ResourceManager } from './ResourceManager';\n\nexport class FireClient {\n  public rm: ResourceManager;\n\n  constructor(\n    public fireWrapper: IFirebaseWrapper,\n    public options: RAFirebaseOptions,\n    public flogger: IFirestoreLogger\n  ) {\n    this.rm = new ResourceManager(this.fireWrapper, this.options, this.flogger);\n  }\n\n  public checkRemoveIdField(obj: any, docId: string) {\n    if (!this.options.dontAddIdFieldToDoc) {\n      obj.id = docId;\n    }\n  }\n\n  public transformToDb(\n    resourceName: string,\n    documentData: any,\n    docId: string\n  ): any {\n    if (typeof this.options.transformToDb === 'function') {\n      return this.options.transformToDb(resourceName, documentData, docId);\n    }\n    return documentData;\n  }\n\n  public async parseDataAndUpload(r: IResource, id: string, data: any) {\n    if (!data) {\n      return data;\n    }\n    const docPath = doc(r.collection, id).path;\n\n    const result = translateDocToFirestore(data);\n    const uploads = result.uploads;\n    await Promise.all(\n      uploads.map(async (u) => {\n        const storagePath = parseStoragePath(\n          u.rawFile,\n          docPath,\n          u.fieldDotsPath,\n          !!this.options.useFileNamesInStorage\n        );\n        const link = await this.saveFile(storagePath, u.rawFile);\n        set(data, u.fieldDotsPath + '.src', link);\n      })\n    );\n    return data;\n  }\n\n  public async addCreatedByFields(obj: any) {\n    return AddCreatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  public async addUpdatedByFields(obj: any) {\n    return AddUpdatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  private async saveFile(\n    storagePath: string,\n    rawFile: any\n  ): Promise<string | undefined> {\n    log('saveFile() saving file...', { storagePath, rawFile });\n    try {\n      const { task, taskResult, downloadUrl } = this.fireWrapper.putFile(\n        storagePath,\n        rawFile\n      );\n      const { name } = rawFile;\n      // monitor upload status & progress\n      dispatch('FILE_UPLOAD_WILL_START', name);\n      task.on('state_changed', (snapshot) => {\n        const progress =\n          (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n        log('Upload is ' + progress + '% done');\n        dispatch('FILE_UPLOAD_PROGRESS', name, progress);\n        switch (snapshot.state) {\n          case TASK_PAUSED:\n            log('Upload is paused');\n            dispatch('FILE_UPLOAD_PAUSED', name);\n            break;\n          case TASK_RUNNING:\n            log('Upload is running');\n            dispatch('FILE_UPLOAD_RUNNING', name);\n            break;\n          case TASK_CANCELED:\n            log('Upload has been canceled');\n            dispatch('FILE_UPLOAD_CANCELED', name);\n            break;\n          // case storage.TaskState.ERROR:\n          // already handled by catch\n          // case storage.TaskState.SUCCESS:\n          // already handled by then\n        }\n      });\n      const [getDownloadURL] = await Promise.all([downloadUrl, taskResult]);\n      dispatch('FILE_UPLOAD_COMPLETE', name);\n      dispatch('FILE_SAVED', name);\n      log('saveFile() saved file', {\n        storagePath,\n        taskResult,\n        getDownloadURL,\n      });\n      return this.options.relativeFilePaths ? storagePath : getDownloadURL;\n    } catch (storageError) {\n      if (get(storageError, 'code') === 'storage/unknown') {\n        logError(\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\n          { storageError }\n        );\n      } else {\n        logError('saveFile() error saving file', {\n          storageError,\n        });\n      }\n    }\n  }\n}\n","import { joinPaths } from './pathHelper';\n\nexport function parseStoragePath(\n  rawFile: File,\n  docPath: string,\n  fieldPath: string,\n  useFileName: boolean\n): string {\n  const fileNameBits = rawFile instanceof File ? rawFile.name.split('.') : [];\n\n  const fileExtension = !fileNameBits?.length ? '' : '.' + fileNameBits.pop();\n\n  return useFileName\n    ? joinPaths(docPath, fieldPath, rawFile.name)\n    : joinPaths(docPath, fieldPath + fileExtension);\n}\n","import { RAFirebaseOptions } from 'index';\nimport { IFirebaseWrapper, ResourceManager } from 'providers/database';\n\nexport async function AddCreatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\n  options: Pick<\n    RAFirebaseOptions,\n    | 'associateUsersById'\n    | 'disableMeta'\n    | 'renameMetaFields'\n    | 'metaFieldCasing'\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const createAtSelector = GetSelectorsCreateAt(options);\n  const createBySelector = GetSelectorsCreateBy(options);\n  obj[createAtSelector] = fireWrapper.serverTimestamp();\n  obj[createBySelector] = currentUserIdentifier;\n}\n\nexport async function AddUpdatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\n  options: Pick<\n    RAFirebaseOptions,\n    | 'associateUsersById'\n    | 'disableMeta'\n    | 'renameMetaFields'\n    | 'metaFieldCasing'\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const updateAtSelector = GetSelectorsUpdateAt(options);\n  const updateBySelector = GetSelectorsUpdateBy(options);\n  obj[updateAtSelector] = fireWrapper.serverTimestamp();\n  obj[updateBySelector] = currentUserIdentifier;\n}\n\nexport function GetSelectorsUpdateAt(\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_at) {\n    return options.renameMetaFields.updated_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = 'lastupdate';\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === 'camel') {\n    return 'lastUpdate';\n  }\n  if (casing === 'snake') {\n    return 'last_update';\n  }\n  if (casing === 'pascal') {\n    return 'LastUpdate';\n  }\n  if (casing === 'kebab') {\n    return 'last-update';\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsUpdateBy(\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_by) {\n    return options.renameMetaFields.updated_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = 'updatedby';\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === 'camel') {\n    return 'updatedBy';\n  }\n  if (casing === 'snake') {\n    return 'updated_by';\n  }\n  if (casing === 'pascal') {\n    return 'UpdatedBy';\n  }\n  if (casing === 'kebab') {\n    return 'updated-by';\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateAt(\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_at) {\n    return options.renameMetaFields.created_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = 'createdate';\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === 'camel') {\n    return 'createDate';\n  }\n  if (casing === 'snake') {\n    return 'create_date';\n  }\n  if (casing === 'pascal') {\n    return 'CreateDate';\n  }\n  if (casing === 'kebab') {\n    return 'create-date';\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateBy(\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_by) {\n    return options.renameMetaFields.created_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = 'createdby';\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === 'camel') {\n    return 'createdBy';\n  }\n  if (casing === 'snake') {\n    return 'created_by';\n  }\n  if (casing === 'pascal') {\n    return 'CreatedBy';\n  }\n  if (casing === 'kebab') {\n    return 'created-by';\n  }\n  return defautCase;\n}\n","import { FirebaseApp } from 'firebase/app';\nimport { Auth, User, UserCredential } from 'firebase/auth';\nimport {\n  CollectionReference,\n  DocumentData,\n  DocumentReference,\n  DocumentSnapshot,\n  FieldValue,\n  Firestore,\n  OrderByDirection,\n  Query,\n  QueryDocumentSnapshot,\n  WriteBatch,\n} from 'firebase/firestore';\nimport {\n  FirebaseStorage,\n  StorageReference,\n  TaskState,\n  UploadTask,\n  UploadTaskSnapshot,\n} from 'firebase/storage';\n\nexport type FireUser = User;\nexport type FireApp = FirebaseApp;\n\nexport type FireStorage = FirebaseStorage;\nexport type FireStorageReference = StorageReference;\nexport type FireUploadTaskSnapshot = UploadTaskSnapshot;\nexport type FireUploadTask = UploadTask;\nexport type FireStoragePutFileResult = {\n  task: FireUploadTask;\n  taskResult: Promise<FireUploadTaskSnapshot>;\n  downloadUrl: Promise<string>;\n};\n\nexport type FireAuth = Auth;\nexport type FireAuthUserCredentials = UserCredential;\n\nexport type FireStore = Firestore;\nexport type FireStoreBatch = WriteBatch;\nexport type FireStoreTimeStamp = FieldValue;\nexport type FireStoreDocumentRef = DocumentReference;\nexport type FireStoreDocumentSnapshot = DocumentSnapshot<DocumentData>;\nexport type FireStoreCollectionRef = CollectionReference;\nexport type FireStoreQueryDocumentSnapshot = QueryDocumentSnapshot;\nexport type FireStoreQuery = Query;\nexport type FireStoreQueryOrder = OrderByDirection;\n\nexport const TASK_PAUSED = 'paused' as TaskState;\nexport const TASK_RUNNING = 'running' as TaskState;\nexport const TASK_CANCELED = 'cancelled' as TaskState;\n","import {\n  doc,\n  getDoc,\n  getDocs,\n  limit,\n  query,\n  QueryConstraint,\n  startAfter,\n  startAt,\n} from 'firebase/firestore';\nimport { ref } from 'firebase/storage';\nimport {\n  FireStoreCollectionRef,\n  FireStoreDocumentSnapshot,\n  FireStoreQuery,\n} from 'misc/firebase-models';\nimport { IFirestoreLogger, messageTypes } from '../../misc';\n\nexport function setQueryCursor(\n  document: FireStoreDocumentSnapshot,\n  params: messageTypes.IParamsGetList,\n  resourceName: string\n) {\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\n  localStorage.setItem(key, document.id);\n\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\n  if (!localCursorKeys) {\n    localStorage.setItem(allCursorsKey, JSON.stringify([key]));\n  } else {\n    const cursors: string[] = JSON.parse(localCursorKeys);\n    const newCursors = cursors.concat(key);\n    localStorage.setItem(allCursorsKey, JSON.stringify(newCursors));\n  }\n}\n\nexport async function getQueryCursor(\n  collection: FireStoreCollectionRef,\n  params: messageTypes.IParamsGetList,\n  resourceName: string,\n  flogger: IFirestoreLogger\n): Promise<FireStoreDocumentSnapshot | false> {\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\n  const docId = localStorage.getItem(key);\n  if (!docId) {\n    return false;\n  }\n\n  const docSnapshot = await getDoc(doc(collection, docId));\n  flogger.logDocument(1)();\n  if (docSnapshot.exists()) {\n    return docSnapshot;\n  }\n  return false;\n}\n\nexport function clearQueryCursors(resourceName: string) {\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\n  if (localCursorKeys) {\n    const cursors: string[] = JSON.parse(localCursorKeys);\n    cursors.forEach((cursor) => localStorage.removeItem(cursor));\n    localStorage.removeItem(allCursorsKey);\n  }\n}\n\nexport async function findLastQueryCursor(\n  collection: FireStoreCollectionRef,\n  queryConstraints: QueryConstraint[],\n  params: messageTypes.IParamsGetList,\n  resourceName: string,\n  flogger: IFirestoreLogger\n) {\n  const { page, perPage } = params.pagination;\n\n  let lastQueryCursor: FireStoreDocumentSnapshot | false = false;\n  let currentPage = page - 1;\n\n  const currentPageParams = {\n    ...params,\n    pagination: {\n      ...params.pagination,\n    },\n  };\n  while (!lastQueryCursor && currentPage > 1) {\n    currentPage--;\n    currentPageParams.pagination.page = currentPage;\n    console.log('getting query cursor currentPage=', currentPage);\n    lastQueryCursor = await getQueryCursor(\n      collection,\n      currentPageParams,\n      resourceName,\n      flogger\n    );\n  }\n  const pageLimit = (page - currentPage) * perPage;\n  const isFirst = currentPage === 1;\n\n  function getQuery() {\n    if (isFirst) {\n      return query(collection, ...[...queryConstraints, limit(pageLimit)]);\n    } else {\n      return query(\n        collection,\n        ...[...queryConstraints, startAfter(lastQueryCursor), limit(pageLimit)]\n      );\n    }\n  }\n\n  const newQuery = getQuery();\n  const snapshots = await getDocs(newQuery);\n  const docsLength = snapshots.docs.length;\n  flogger.logDocument(docsLength)();\n  const lastDocIndex = docsLength - 1;\n  const lastDocRef = snapshots.docs[lastDocIndex];\n  return lastDocRef;\n}\n","import {\n  getDocs,\n  limit,\n  orderBy,\n  query,\n  QueryConstraint,\n  startAfter,\n  where,\n} from 'firebase/firestore';\nimport {\n  FireStoreCollectionRef,\n  FireStoreQuery,\n  FireStoreQueryOrder,\n} from 'misc/firebase-models';\nimport { IFirestoreLogger, messageTypes } from '../../misc';\nimport { findLastQueryCursor, getQueryCursor } from './queryCursors';\n\ninterface ParamsToQueryOptions {\n  filters?: boolean;\n  sort?: boolean;\n  pagination?: boolean;\n}\n\ninterface QueryPair {\n  noPagination: FireStoreQuery;\n  withPagination: FireStoreQuery;\n}\n\nconst defaultParamsToQueryOptions = {\n  filters: true,\n  sort: true,\n  pagination: true,\n};\n\nexport async function paramsToQuery<\n  TParams extends messageTypes.IParamsGetList\n>(\n  collection: FireStoreCollectionRef,\n  params: TParams,\n  resourceName: string,\n  flogger: IFirestoreLogger,\n  options: ParamsToQueryOptions = defaultParamsToQueryOptions\n): Promise<QueryPair> {\n  const filterConstraints = options.filters\n    ? getFiltersConstraints(params.filter)\n    : [];\n\n  const sortConstraints = options.sort ? getSortConstraints(params.sort) : [];\n\n  const paginationConstraints = options.pagination\n    ? await getPaginationConstraints(\n        collection,\n        [...filterConstraints, ...sortConstraints],\n        params,\n        resourceName,\n        flogger\n      )\n    : [];\n\n  return {\n    noPagination: query(\n      collection,\n      ...[...filterConstraints, ...sortConstraints]\n    ),\n    withPagination: query(\n      collection,\n      ...[...filterConstraints, ...sortConstraints, ...paginationConstraints]\n    ),\n  };\n}\n\nexport function getFiltersConstraints(filters: {\n  [fieldName: string]: any;\n}): QueryConstraint[] {\n  return Object.entries(filters).flatMap(([fieldName, fieldValue]) => {\n    if (Array.isArray(fieldValue)) {\n      return [where(fieldName, 'array-contains-any', fieldValue)];\n    } else if (Object.keys(filters).length === 1 && isNaN(fieldValue)) {\n      return [\n        where(fieldName, '>=', fieldValue),\n        where(fieldName, '<', fieldValue + 'z'),\n      ];\n    } else {\n      return [where(fieldName, '==', fieldValue)];\n    }\n  });\n}\n\nexport function getSortConstraints(sort: {\n  field: string;\n  order: string;\n}): QueryConstraint[] {\n  if (sort != null && sort.field !== 'id') {\n    const { field, order } = sort;\n    const parsedOrder = order.toLocaleLowerCase() as FireStoreQueryOrder;\n    return [orderBy(field, parsedOrder)];\n  }\n  return [];\n}\n\nasync function getPaginationConstraints<\n  TParams extends messageTypes.IParamsGetList\n>(\n  collectionRef: FireStoreCollectionRef,\n  queryConstraints: QueryConstraint[],\n  params: TParams,\n  resourceName: string,\n  flogger: IFirestoreLogger\n): Promise<QueryConstraint[]> {\n  const { page, perPage } = params.pagination;\n\n  if (page === 1) {\n    return [limit(perPage)];\n  } else {\n    let queryCursor = await getQueryCursor(\n      collectionRef,\n      params,\n      resourceName,\n      flogger\n    );\n    if (!queryCursor) {\n      queryCursor = await findLastQueryCursor(\n        collectionRef,\n        queryConstraints,\n        params,\n        resourceName,\n        flogger\n      );\n    }\n    return [startAfter(queryCursor), limit(perPage)];\n  }\n}\n\nexport function getFullParamsForQuery<\n  TParams extends messageTypes.IParamsGetList\n>(reactAdminParams: TParams, softdeleteEnabled: boolean): TParams {\n  return {\n    ...reactAdminParams,\n    filter: softdeleteEnabled\n      ? {\n          deleted: false,\n          ...reactAdminParams.filter,\n        }\n      : reactAdminParams.filter,\n  };\n}\n\nexport function getNextPageParams<TParams extends messageTypes.IParamsGetList>(\n  params: TParams\n): TParams {\n  return {\n    ...params,\n    pagination: {\n      ...params.pagination,\n      page: params.pagination.page + 1,\n    },\n  };\n}\n","import { getCountFromServer, getDocs } from 'firebase/firestore';\nimport {\n  log,\n  messageTypes,\n  parseFireStoreDocument,\n  recursivelyMapStorageUrls,\n} from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient, IResource, ResourceManager } from '../database';\nimport { RAFirebaseOptions } from '../options';\nimport {\n  getFullParamsForQuery,\n  getNextPageParams,\n  paramsToQuery,\n} from './paramsToQuery';\nimport { setQueryCursor } from './queryCursors';\n\nexport class FirebaseLazyLoadingClient {\n  constructor(\n    private readonly options: RAFirebaseOptions,\n    private readonly rm: ResourceManager,\n    private client: FireClient\n  ) {}\n\n  public async apiGetList<T extends ra.Record>(\n    resourceName: string,\n    reactAdminParams: ra.GetListParams\n  ): Promise<ra.GetListResult<T>> {\n    const r = await this.tryGetResource(resourceName);\n    const params = getFullParamsForQuery(\n      reactAdminParams,\n      !!this.options.softDelete\n    );\n\n    log('apiGetListLazy', { resourceName, params });\n\n    const { noPagination, withPagination } = await paramsToQuery(\n      r.collection,\n      params,\n      resourceName,\n      this.client.flogger\n    );\n\n    const snapshots = await getDocs(withPagination);\n\n    const resultsCount = snapshots.docs.length;\n    if (!resultsCount) {\n      log('apiGetListLazy', {\n        message: 'There are not records for given query',\n      });\n      return { data: [], total: 0 };\n    }\n    this.client.flogger.logDocument(resultsCount)();\n\n    // tslint:disable-next-line\n    const data = snapshots.docs.map((d) => parseFireStoreDocument<T>(d));\n\n    const nextPageCursor = snapshots.docs[snapshots.docs.length - 1];\n    // After fetching documents save queryCursor for next page\n    setQueryCursor(nextPageCursor, getNextPageParams(params), resourceName);\n    // Hardcoded to allow next pages, as we don't have total number of items\n\n    let total = await getCountFromServer(noPagination);\n\n    if (this.options.relativeFilePaths) {\n      const parsedData = await Promise.all(\n        data.map(async (doc: any) => {\n          for (let fieldName in doc) {\n            doc[fieldName] = await recursivelyMapStorageUrls(\n              this.client.fireWrapper,\n              doc[fieldName]\n            );\n          }\n          return doc;\n        })\n      );\n\n      log('apiGetListLazy result', {\n        docs: parsedData,\n        resource: r,\n        collectionPath: r.collection.path,\n      });\n\n      return {\n        data: parsedData,\n        total: total.data().count,\n      };\n    }\n\n    log('apiGetListLazy result', {\n      docs: data,\n      resource: r,\n      collectionPath: r.collection.path,\n    });\n\n    return { data, total: total.data().count };\n  }\n\n  public async apiGetManyReference(\n    resourceName: string,\n    reactAdminParams: messageTypes.IParamsGetManyReference\n  ): Promise<messageTypes.IResponseGetManyReference> {\n    const r = await this.tryGetResource(resourceName);\n    log('apiGetManyReferenceLazy', {\n      resourceName,\n      resource: r,\n      reactAdminParams,\n    });\n    const filterWithTarget = {\n      ...reactAdminParams.filter,\n      [reactAdminParams.target]: reactAdminParams.id,\n    };\n    const params = getFullParamsForQuery(\n      {\n        ...reactAdminParams,\n        filter: filterWithTarget,\n      },\n      !!this.options.softDelete\n    );\n\n    const { withPagination } = await paramsToQuery(\n      r.collection,\n      params,\n      resourceName,\n      this.client.flogger\n    );\n\n    const snapshots = await getDocs(withPagination);\n    const resultsCount = snapshots.docs.length;\n    this.client.flogger.logDocument(resultsCount)();\n    const data = snapshots.docs.map(parseFireStoreDocument);\n    if (this.options.relativeFilePaths) {\n      const parsedData = await Promise.all(\n        data.map(async (doc: any) => {\n          for (let fieldName in doc) {\n            doc[fieldName] = await recursivelyMapStorageUrls(\n              this.client.fireWrapper,\n              doc[fieldName]\n            );\n          }\n          return doc;\n        })\n      );\n\n      log('apiGetManyReferenceLazy result', {\n        docs: parsedData,\n        resource: r,\n        collectionPath: r.collection.path,\n      });\n\n      return {\n        data: parsedData,\n        total: data.length,\n      };\n    }\n\n    log('apiGetManyReferenceLazy result', {\n      docs: data,\n      resource: r,\n      collectionPath: r.collection.path,\n    });\n    return { data, total: data.length };\n  }\n\n  private async tryGetResource(\n    resourceName: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n}\n","import {\n  getAbsolutePath,\n  log,\n  logError,\n  logger,\n  MakeFirestoreLogger,\n  retrieveStatusCode,\n} from '../misc';\nimport { FireApp } from '../misc/firebase-models';\nimport * as ra from '../misc/react-admin-models';\nimport { Create, Delete, DeleteMany, Update, UpdateMany } from './commands';\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\nimport { FireClient } from './database/FireClient';\nimport { RAFirebaseOptions } from './options';\nimport { GetList, GetMany, GetManyReference, GetOne } from './queries';\n\nexport interface IDataProvider extends ra.DataProvider {\n  app: FireApp;\n}\n\nexport function DataProvider(\n  firebaseConfig: {},\n  optionsInput?: RAFirebaseOptions\n): IDataProvider {\n  const options = optionsInput || {};\n  verifyDataProviderArgs(firebaseConfig, options);\n\n  const flogger = MakeFirestoreLogger(options);\n  logger.SetEnabled(!!options?.logging);\n  flogger.SetEnabled(!!options?.firestoreCostsLogger?.enabled);\n  flogger.ResetCount(!options?.firestoreCostsLogger?.persistCount);\n  log('Creating FirebaseDataProvider', {\n    firebaseConfig,\n    options,\n  });\n\n  const fireWrapper = new FirebaseWrapper(optionsInput, firebaseConfig);\n\n  async function run<T>(cb: () => Promise<T>) {\n    let res: any;\n    try {\n      res = await cb();\n      return res;\n    } catch (error) {\n      const errorMsg = ((error as any) || '').toString();\n      const code = retrieveStatusCode(errorMsg);\n      const errorObj = { status: code, message: errorMsg, json: res };\n      logError('DataProvider:', error, { errorMsg, code, errorObj });\n      throw errorObj;\n    }\n  }\n  const client = new FireClient(fireWrapper, options, flogger);\n\n  const newProviderApi: IDataProvider = {\n    app: fireWrapper.GetApp(),\n    getList<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetListParams\n    ): Promise<ra.GetListResult<RecordType>> {\n      return run(() => GetList<RecordType>(resource, params, client));\n    },\n    getOne<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetOneParams\n    ): Promise<ra.GetOneResult<RecordType>> {\n      return run(() => GetOne<RecordType>(resource, params, client));\n    },\n    getMany<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyParams\n    ): Promise<ra.GetManyResult<RecordType>> {\n      return run(() => GetMany<RecordType>(resource, params, client));\n    },\n    getManyReference<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyReferenceParams\n    ): Promise<ra.GetManyReferenceResult<RecordType>> {\n      return run(() => GetManyReference<RecordType>(resource, params, client));\n    },\n    update<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.UpdateParams\n    ): Promise<ra.UpdateResult<RecordType>> {\n      return run(() => Update<RecordType>(resource, params, client));\n    },\n    updateMany(\n      resource: string,\n      params: ra.UpdateManyParams\n    ): Promise<ra.UpdateManyResult> {\n      return run(() => UpdateMany(resource, params, client));\n    },\n    create<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.CreateParams\n    ): Promise<ra.CreateResult<RecordType>> {\n      return run(() => Create<RecordType>(resource, params, client));\n    },\n    delete<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.DeleteParams\n    ): Promise<ra.DeleteResult<RecordType>> {\n      return run(() => Delete(resource, params, client));\n    },\n    deleteMany(\n      resource: string,\n      params: ra.DeleteManyParams\n    ): Promise<ra.DeleteManyResult> {\n      return run(() => DeleteMany(resource, params, client));\n    },\n  };\n\n  return newProviderApi;\n}\n\nfunction verifyDataProviderArgs(\n  firebaseConfig: {},\n  options?: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\n    );\n  }\n  if (options && options.rootRef) {\n    // Will throw error if rootRef doesn't point to a document\n    getAbsolutePath(options.rootRef, 'test');\n  }\n}\n","import {\n  filterArray,\n  log,\n  recursivelyMapStorageUrls,\n  sortArray,\n} from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\nimport { FirebaseLazyLoadingClient } from '../lazy-loading/FirebaseLazyLoadingClient';\n\nexport async function GetList<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetListParams,\n  client: FireClient\n): Promise<ra.GetListResult<T>> {\n  log('GetList', { resourceName, params });\n  const { rm, fireWrapper, options } = client;\n\n  if (options?.lazyLoading?.enabled) {\n    const lazyClient = new FirebaseLazyLoadingClient(options, rm, client);\n    return lazyClient.apiGetList<T>(resourceName, params);\n  }\n\n  const filterSafe = params.filter || {};\n\n  const collectionQuery = filterSafe.collectionQuery;\n  delete filterSafe.collectionQuery;\n\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\n  const data = r.list;\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === 'ASC') {\n      sortArray(data, field, 'asc');\n    } else {\n      sortArray(data, field, 'desc');\n    }\n  }\n  let softDeleted = data;\n  if (options.softDelete && !Object.keys(filterSafe).includes('deleted')) {\n    softDeleted = data.filter((doc) => !doc.deleted);\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = filteredData.slice(pageStart, pageEnd) as T[];\n  const total = filteredData.length;\n\n  if (options.relativeFilePaths) {\n    const fetchedData = await Promise.all(\n      dataPage.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return {\n      data: fetchedData,\n      total,\n    };\n  }\n\n  return {\n    data: dataPage,\n    total,\n  };\n}\n","import { log, translateDocFromFirestore } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\n\nexport async function GetOne<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetOneParams,\n  client: FireClient\n): Promise<ra.GetOneResult<T>> {\n  log('GetOne', { resourceName, params });\n  const { rm } = client;\n  try {\n    const id = params.id + '';\n    const dataSingle = await rm.GetSingleDoc(resourceName, id);\n    client.flogger.logDocument(1)();\n    return { data: dataSingle as T };\n  } catch (error) {\n    throw new Error(\n      'Error getting id: ' + params.id + ' from collection: ' + resourceName\n    );\n  }\n}\n","import { doc, getDoc } from 'firebase/firestore';\nimport { log, recursivelyMapStorageUrls } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\n\nexport async function GetMany<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyParams,\n  client: FireClient\n): Promise<ra.GetManyResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  const ids = params.ids;\n  log('GetMany', { resourceName, resource: r, params, ids });\n  const matchDocSnaps = await Promise.all(\n    ids.map((idObj) => {\n      if (typeof idObj === 'string') {\n        return getDoc(doc(r.collection, idObj));\n      }\n      // Will get and resolve reference documents into the current doc\n      return getDoc(doc(r.collection, (idObj as any)['___refid']));\n    })\n  );\n  client.flogger.logDocument(ids.length)();\n  const matches = matchDocSnaps.map(\n    (snap) => ({ ...snap.data(), id: snap.id } as T)\n  );\n  const permittedData = options.softDelete\n    ? matches.filter((row) => !row['deleted'])\n    : matches;\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      permittedData.map((d) => recursivelyMapStorageUrls(fireWrapper, d))\n    );\n    return {\n      data,\n    };\n  }\n\n  return {\n    data: permittedData,\n  };\n}\n","import {\n  filterArray,\n  log,\n  recursivelyMapStorageUrls,\n  sortArray,\n} from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\n\nexport async function GetManyReference<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyReferenceParams,\n  client: FireClient\n): Promise<ra.GetManyReferenceResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  log('GetManyReference', { resourceName, params });\n  const filterSafe = params.filter || {};\n  const collectionQuery = filterSafe.collectionQuery;\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\n  delete filterSafe.collectionQuery;\n  log('apiGetManyReference', { resourceName, resource: r, params });\n  const data = r.list;\n  const targetField = params.target;\n  const targetValue = params.id;\n  let softDeleted = data;\n  if (options.softDelete) {\n    softDeleted = data.filter((doc) => !doc['deleted']);\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const targetIdFilter: Record<string, ra.Identifier> = {};\n  targetIdFilter[targetField] = targetValue;\n  const permittedData = filterArray(filteredData, targetIdFilter);\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === 'ASC') {\n      sortArray(permittedData, field, 'asc');\n    } else {\n      sortArray(permittedData, field, 'desc');\n    }\n  }\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = permittedData.slice(pageStart, pageEnd) as T[];\n  const total = permittedData.length;\n\n  if (options.relativeFilePaths) {\n    const fetchedData = await Promise.all(\n      permittedData.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return { data: fetchedData, total };\n  }\n\n  return { data: dataPage, total };\n}\n","import { doc, updateDoc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\n\nexport async function Update<T extends ra.Record>(\n  resourceName: string,\n  params: ra.UpdateParams,\n  client: FireClient\n): Promise<ra.UpdateResult<T>> {\n  const { rm } = client;\n  log('Update', { resourceName, params });\n  const id = params.id + '';\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log('Update', { resourceName, resource: r, params });\n  const data = await client.parseDataAndUpload(r, id, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj, id);\n  await client.addUpdatedByFields(docObj);\n  const docObjTransformed = client.transformToDb(resourceName, docObj, id);\n  await updateDoc(doc(r.collection, id), docObjTransformed);\n  return {\n    data: {\n      ...data,\n      id: id,\n    },\n  };\n}\n","import { doc, updateDoc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\n\nexport async function UpdateMany(\n  resourceName: string,\n  params: ra.UpdateManyParams,\n  client: FireClient\n): Promise<ra.UpdateManyResult> {\n  const { rm } = client;\n  log('UpdateMany', { resourceName, params });\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log('UpdateMany', { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async (id) => {\n      const idStr = id + '';\n      const data = await client.parseDataAndUpload(r, idStr, params.data);\n      const docObj = { ...data };\n      client.checkRemoveIdField(docObj, idStr);\n      await client.addUpdatedByFields(docObj);\n      const docObjTransformed = client.transformToDb(\n        resourceName,\n        docObj,\n        idStr\n      );\n      await updateDoc(doc(r.collection, idStr), docObjTransformed);\n      return {\n        ...data,\n        id: idStr,\n      };\n    })\n  );\n  return {\n    data: returnData,\n  };\n}\n","import { doc, getDoc, setDoc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\n\nexport async function Create<T extends ra.Record>(\n  resourceName: string,\n  params: ra.CreateParams,\n  client: FireClient\n): Promise<ra.CreateResult<T>> {\n  const { rm, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log('Create', { resourceName, resource: r, params });\n  const hasOverridenDocId = params.data && params.data.id;\n  log('Create', { hasOverridenDocId });\n  if (hasOverridenDocId) {\n    const overridenId = params.data.id;\n    const exists = (await getDoc(doc(r.collection, overridenId))).exists();\n    if (exists) {\n      throw new Error(\n        `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\n      );\n    }\n\n    const createData = await client.parseDataAndUpload(\n      r,\n      overridenId,\n      params.data\n    );\n    if (!overridenId) {\n      throw new Error('id must be a valid string');\n    }\n    const createDocObj = { ...createData };\n    client.checkRemoveIdField(createDocObj, overridenId);\n    await client.addCreatedByFields(createDocObj);\n    await client.addUpdatedByFields(createDocObj);\n    const createDocObjTransformed = client.transformToDb(\n      resourceName,\n      createDocObj,\n      overridenId\n    );\n    log('Create', { docObj: createDocObj });\n    await setDoc(doc(r.collection, overridenId), createDocObjTransformed, {\n      merge: false,\n    });\n    return {\n      data: {\n        ...createDocObjTransformed,\n        id: overridenId,\n      },\n    };\n  }\n  const newId = fireWrapper.dbMakeNewId();\n  const data = await client.parseDataAndUpload(r, newId, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj, newId);\n  await client.addCreatedByFields(docObj);\n  await client.addUpdatedByFields(docObj);\n  const docObjTransformed = client.transformToDb(resourceName, docObj, newId);\n  await setDoc(doc(r.collection, newId), docObjTransformed, { merge: false });\n  return {\n    data: {\n      ...docObjTransformed,\n      id: newId,\n    },\n  };\n}\n","import { deleteDoc, doc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database/FireClient';\nimport { DeleteSoft } from './Delete.Soft';\n\nexport async function Delete<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm, options } = client;\n  if (options.softDelete) {\n    return DeleteSoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log('apiDelete', { resourceName, resource: r, params });\n  try {\n    const id = params.id + '';\n\n    await deleteDoc(doc(r.collection, id));\n  } catch (error) {\n    throw new Error(error as any);\n  }\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { doc, updateDoc } from 'firebase/firestore';\nimport { log, logError } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\n\nexport async function DeleteSoft<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm } = client;\n  const id = params.id + '';\n  const r = await rm.TryGetResource(resourceName);\n  log('DeleteSoft', { resourceName, resource: r, params });\n  const docObj = { deleted: true };\n  await client.addUpdatedByFields(docObj);\n\n  updateDoc(doc(r.collection, id), docObj).catch((error) => {\n    logError('DeleteSoft error', { error });\n  });\n\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { doc } from 'firebase/firestore';\nimport { log } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\nimport { DeleteManySoft } from './DeleteMany.Soft';\n\nexport async function DeleteMany(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { options, rm, fireWrapper } = client;\n  if (options.softDelete) {\n    return DeleteManySoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log('DeleteMany', { resourceName, resource: r, params });\n  const returnData: ra.Identifier[] = [];\n  const batch = fireWrapper.dbCreateBatch();\n  for (const id of params.ids) {\n    const idStr = id + '';\n    const docToDelete = doc(r.collection, idStr);\n    batch.delete(docToDelete);\n    returnData.push(id);\n  }\n\n  try {\n    await batch.commit();\n  } catch (error) {\n    throw new Error(error as any);\n  }\n  return { data: returnData };\n}\n","import { doc, updateDoc } from 'firebase/firestore';\nimport { log, logError } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\nimport { FireClient } from '../database';\n\nexport async function DeleteManySoft(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { rm } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log('DeleteManySoft', { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async (id) => {\n      const idStr = id + '';\n      const docObj = { deleted: true };\n      await client.addUpdatedByFields(docObj);\n      updateDoc(doc(r.collection, idStr), docObj).catch((error) => {\n        logError('apiSoftDeleteMany error', { error });\n      });\n      return idStr;\n    })\n  );\n  return {\n    data: returnData,\n  };\n}\n"],"names":["sortArray","data","field","dir","sort","a","b","get","rawB","isAsc","Number","isFinite","rawA","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","Object","keys","map","fieldName","getSubObjects","value","searchField","searchValue","tree","objectFlatten","leaves","recursivelyWalk","obj","path","key","hasOwnProperty","objVal","currentPath","Array","push","getFieldReferences","filter","row","reduce","acc","cur","res","doesRowMatch","searchThis","toString","includes","isArray","LogNoOp","args","LoggerBase","constructor","title","cacheEnabledKey","this","isEnabled","localStorage","getItem","SetEnabled","setItem","removeItem","log","console","bind","warn","error","KEY_SINGLE","logger","logError","dispatch","eventName","fileName","eventMonitor","document","getElementById","event","CustomEvent","detail","dispatchEvent","REF_INDENTIFIER","translateDocFromFirestore","result","parsedDoc","refdocs","recusivelyCheckObjectValue","input","fieldPath","toDate","index","isInputADocReference","refDocPath","documentReference","id","firestore","parent","recursivelyMapStorageUrls","async","fireWrapper","fieldValue","has","src","getDownloadURL","ref","storage","Promise","all","parseFireStoreDocument","doc","logWarn","refDocs","d","set","applyRefDocs","dataWithRefs","rootRef","relativePath","Error","rootRefValue","join","withSlashes","split","length","slice","joinPaths","translateDocToFirestore","uploads","recusivelyParseObjectValue","fieldDotsPath","refPath","fieldSlashesPath","rawFile","inputOptions","firebaseConfig","_app","_firestore","_storage","_auth","options","optionsSafe","window","app","getApps","apps","getApp","initializeApp","ObtainFirebaseApp","getFirestore","database","getStorage","getAuth","dbGetCollection","absolutePath","collection","dbCreateBatch","dbMakeNewId","OnUserLogout","callBack","onAuthStateChanged","user","isLoggedOut","putFile","storagePath","task","uploadBytesResumable","taskResult","rej","then","catch","downloadUrl","t","url","fieldSrc","serverTimestamp","firestoreServerTimestamp","persistenceInput","persistenceResolved","browserLocalPersistence","inMemoryPersistence","browserSessionPersistence","setPersistence","email","password","signInWithEmailAndPassword","signOut","resolve","reject","auth","currentUser","unsubscribe","authGetUserLoggedIn","GetApp","db","optionsInput","FirebaseWrapper","persistence","authSetPersistence","params","username","getUserLogin","authSigninEmailPassword","e","HandleAuthLogout","authSignOut","HandleAuthError","errorHttp","retrieveStatusTxt","status","getIdTokenResult","claims","uid","displayName","photoURL","fullName","avatar","authTime","expirationTime","signInProvider","issuedAtTime","token","AuthProvider","VerifyAuthProviderArgs","logging","AuthClient","login","HandleAuthLogin","logout","checkAuth","HandleAuthCheck","checkError","getPermissions","HandleGetPermissions","getIdentity","HandleGetIdentity","getAuthUser","getJWTAuthTime","HandleGetJWTAuthTime","getJWTExpirationTime","HandleGetJWTExpirationTime","getJWTSignInProvider","HandleGetJWTSignInProvider","getJWTClaims","getJWTToken","HandleGetJWTToken","ResourceManager","flogger","resources","resourceName","refresh","collectionQuery","RefreshResource","TryGetResourcePromise","GetResource","resource","initPath","_this$options","_this$options$lazyLoa","lazyLoading","enabled","collectionRef","applyQuery","newDocs","getDocs","collectionOrQuery","list","forEach","logDocument","docs","collectionPath","docId","docSnap","getDoc","exists","getAbsolutePath","hasBeenInited","pathAbsolute","allResources","associateUsersById","getCurrentUserId","getCurrentUserEmail","collRef","FireClient","rm","checkRemoveIdField","dontAddIdFieldToDoc","transformToDb","documentData","r","_this","docPath","u","parseStoragePath","useFileName","fileNameBits","File","name","fileExtension","pop","useFileNamesInStorage","saveFile","link","disableMeta","currentUserIdentifier","getUserIdentifier","createAtSelector","renameMetaFields","created_at","casing","metaFieldCasing","defautCase","GetSelectorsCreateAt","createBySelector","created_by","GetSelectorsCreateBy","AddCreatedByFields","updateAtSelector","GetSelectorsUpdateAt","updated_at","updateBySelector","updated_by","GetSelectorsUpdateBy","AddUpdatedByFields","on","snapshot","progress","bytesTransferred","totalBytes","state","relativeFilePaths","storageError","getQueryCursor","btoa","JSON","stringify","_extends","docSnapshot","defaultParamsToQueryOptions","filters","pagination","paramsToQuery","filterConstraints","entries","flatMap","where","isNaN","sortConstraints","order","parsedOrder","toLocaleLowerCase","orderBy","getSortConstraints","paginationConstraints","queryConstraints","page","perPage","limit","queryCursor","lastQueryCursor","currentPageParams","currentPage","pageLimit","newQuery","query","startAfter","snapshots","docsLength","findLastQueryCursor","getPaginationConstraints","noPagination","withPagination","getFullParamsForQuery","reactAdminParams","softdeleteEnabled","deleted","FirebaseLazyLoadingClient","client","tryGetResource","softDelete","resultsCount","message","total","allCursorsKey","localCursorKeys","newCursors","parse","concat","setQueryCursor","getNextPageParams","getCountFromServer","parsedData","count","_this2","target","filterWithTarget","DataProvider","_options$firestoreCos","_options$firestoreCos2","verifyDataProviderArgs","MakeFirestoreLogger","ResetCount","shouldReset","docCount","_options$lazyLoading","incrementBy","incremented","parseInt","currentCountRaw","incrementRead","firestoreCostsLogger","persistCount","run","cb","errorMsg","code","statusTxt","regexResult","exec","retrieveStatusCode","errorObj","json","newProviderApi","getList","apiGetList","filterSafe","TryGetResource","softDeleted","filteredData","pageStart","dataPage","fetchedData","GetList","getOne","GetOne","dataSingle","GetSingleDoc","getMany","GetMany","ids","matchDocSnaps","idObj","snap","permittedData","matches","getManyReference","targetField","targetValue","targetIdFilter","GetManyReference","update","parseDataAndUpload","docObj","addUpdatedByFields","updateDoc","docObjTransformed","Update","updateMany","idStr","UpdateMany","create","Create","hasOverridenDocId","overridenId","createData","createDocObj","addCreatedByFields","createDocObjTransformed","merge","newId","setDoc","delete","Delete","previousData","DeleteSoft","deleteDoc","deleteMany","DeleteManySoft","returnData","batch","docToDelete","commit","DeleteMany"],"mappings":"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"}